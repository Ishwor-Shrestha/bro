#!/bin/sh
# 3.5.3

BRO_COMMANDS="create remove list takeover update "

bro_sed () {
	if command -v gsed > /dev/null ; then
		gsed $@
		return 0
	fi

	sed $@
}

bro_expand () {
	echo `sh -c "echo $1"`
}

bro_error () {
	printf "Aye! $1.\n"
}

bro_usage () {
	echo "Project management: bro <subcommand>"
	echo "Available subcommands are:"
	echo "  create     Create a new project."
	echo "  list       List available projects to work on."
	echo "  remove     Delete an existing project."
	echo "  takeover   Let bro handle existing project."
}


bro_create_usage () {
	echo "Usage: bro create [-t template -p path] <project>"
	echo "  project     Name of the project to be created."
	echo "  template    Path to a template. It could be local directory or remote repo."
	echo "  path        Absolute/relative path where the project directory is to be created."
}


bro_remove_usage () {
	echo "Usage: bro remove <project>"
	echo "  project     Name of the project to be removed."
}


bro_takeover_usage () {
	echo "Usage: bro takeover <path> <project>"
	echo "  path      Path to existing project."
	echo "  project   Name of the project."
}

bro_update () {
	cwd=$(pwd)
	cd $BRO_STATION
	git pull origin master
	cd $cwd
}

# setup a project
# like installing dependencies, git, preparing project structure etc
bro_setup () {
  project=$1
  bro_task 'setup' $project
	bro_init $project
}

bro_init () {
  bro_task 'init' $1
}

bro_task () {
  task=$1
	project=$2
	project_reference=`bro_expand "$BRO_STATION/projects/$project"`

	# check if the project exists
	if [ ! -e "$project_reference" ]; then
		bro_error "the project \"$project\" does not exist.\n Create it with $ bro create $1"
		return 1
	fi

  task_file=$(find . -type f -name '$task*')
  if [ ! -z $task_file ] ; then
    $task_file
  fi
}

# creates a project
bro_create () {
	local OPTIND template path opt project_path project_reference template_path

	while getopts :t:p: opt; do
		case  $opt in
			t) template=$OPTARG;;
			p) path=$OPTARG;;
			*) echo "Invalid option: -" $OPTARG;;
		esac
	done

	## get project name
	shift $(($OPTIND-1))
	project=$@

	if [ "$project" = "" ] && [ "$template" = "" ] ; then
		bro_error "you missed the project name"
		bro_create_usage
		return 1
	fi

  if [ "$project" = "" ] && [ ! -z "$(echo $template | bro_sed '/.*\.git/p')" ] ; then
    project="$(echo $template | bro_sed 's/.*\/\(.*\)\.git/\1/')"
  else
    bro_error "Please pass project name"
  fi

	## set project path
	if [ "$path" = "" ] ; then
		project_path=`bro_expand "$WORKSTATION/$project"`
	else
		if [ "$(echo $path | bro_sed -n "/[~\/]/p")" = "" ] ; then
			mkdir -p `bro_expand "$WORKSTATION/$path"`
			project_path=`bro_expand "$WORKSTATION/$path/$project"`
		else
			project_path=`bro_expand "$path/$project"`
		fi
	fi
	## set project reference path
	project_reference=`bro_expand "$BRO_STATION/projects/$project"`

	### check if the project already exists
	if [ -e $project_reference ] ; then
		bro_error "the project \"$project\" already exists"
		return 1
	fi

	## set template
	case $template in
		"")
			template_path=""
			;;
		# templates/name or name
		git@*|http:*|https:*|/*|~*)
			template_path=$template
			;;
		*)
			template_path=`bro_expand "$WORKSTATION/$template"`
			;;
	esac

	## create project directory at specified path
	case $template_path in
		# http or git
		git@*|http:*|https:*)
			git clone $template_path $project_path

			if [ ! -e $project_path ] ; then
				bro_error "it seems template at \"$template_path\" does not exist.\nPlease check the url or the internet connection."
				return
			fi
			;;
		# local path
		*)
			if [ ! -e $template_path ] ; then
				bro_error "the bro template \"$template\" does not exist. Please create one at $WORKSTATION"
				return
			fi

			mkdir -p $project_path

			## copy files from template to project directory
			cp -a $template_path/. $project_path/

			;;
	esac

	## create project reference file
	touch $project_reference
	echo "$project_path" > $project_reference

	## setup project
	bro_setup $project
}

# remove a project
bro_remove () {
	if [[ "$1" = "" ]] ; then
		bro_remove_usage
		return 1
	fi

	project=$1
	project_reference=`bro_expand "$BRO_STATION/projects/$project"`

	# check if the project already exists
	if [ ! -e "$project_reference" ]; then
		bro_error "the project \"$project\" does not exist"
		return 1
	fi

	rm -f $project_reference
}


# list available projects
bro_list () {
	ls $BRO_STATION/projects/
}


# takeover existing projects
bro_takeover () {
	if [ $# = 0 ] ; then
		bro_takeover_usage
		return
	fi

	project_name=$(basename $1)
	project_reference=$BRO_STATION/projects/$project_name
	project_path=`cd $1 && pwd`

	if [ -f $project_reference ] ; then
		echo "Project already exists."
		return
	fi

	if [ ! -d $project_path ] ; then
		echo "$project_path does not exist."
		return
	fi

	## create project reference file
	touch $project_reference
	echo $project_path > $project_reference

	cd $project_path
	bro_task $project_name init
}


bro_exit () {
  if [[ ! -e ".brotasks" ]] ; then
    echo "Please issue this command inside a project directory."
    return 0
  fi
  project=$(basename "`pwd`")

	if [[ $(tmux ls 2>/dev/null | bro_sed -n "/$project:/p") ]]
	then
		tmux kill-session -t $project
		return 0
	fi
	bro_task exit
}

bro () {
	if [ "$#" = "0" ] ; then
		bro_usage
		return 1
	fi

	cmd=$1
	project=$2

	# local OPTIND
	case $cmd in
		create)
			shift
			bro_create $@
			;;
		remove)
			bro_remove $project
			;;
		list)
			bro_list
			;;
		takeover)
			shift
			bro_takeover $@
			;;
    exit)
      bro_exit
      ;;
		update)
			bro_update
			;;
		*)
			bro_task $@
			;;
	esac
}

# autocomplete
_bro () {
	local cur prev

	cur=${COMP_WORDS[COMP_CWORD]}
	prev=${COMP_WORDS[COMP_CWORD-1]}

	projects=$(ls $BRO_STATION/projects)

	# $ bro
	if (( $COMP_CWORD <= 1 )); then
    COMPREPLY=( $(compgen -W '$BRO_COMMANDS' -- $cur) )
		return 0
	fi

	# autocomplete options for create command
	if [[ "$prev" = "create" ]]; then
		COMPREPLY=( $(compgen -W '-p -t' -- $cur) )
		return 0
	fi

	# autocomplete project names for remove command
	if [[ "$prev" = "remove" ]]; then
		COMPREPLY=( $(compgen -W '$projects' -- $cur) )
		return 0
	fi

	if [[ "$prev" = "takeover" ]]; then
		COMPREPLY=( $(compgen -f -- $cur) )
		return 0
	fi

	# no auto completion for list command
	if [[ "$prev" = "list" ]]; then
		return 0
	fi
}

complete -F _bro bro
